<!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Cumulative Greenspace Effect on Perceived Stress</title>
        
        <!-- Tailwind CSS -->
        <script src="https://cdn.tailwindcss.com"></script>
        
        <!-- Plotly.js -->
        <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>

        <style>
            body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; background-color: #f8fafc; }
            .chart-card { background: white; border-radius: 12px; box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.05), 0 2px 4px -1px rgba(0, 0, 0, 0.03); border: 1px solid #e2e8f0; }
            input[type=range] { -webkit-appearance: none; width: 100%; background: transparent; }
            input[type=range]:focus { outline: none; }
            input[type=range]::-webkit-slider-thumb {
                -webkit-appearance: none; height: 18px; width: 18px; border-radius: 50%; 
                background: #2563eb; cursor: pointer; margin-top: -7px; 
                box-shadow: 0 2px 4px rgba(0,0,0,0.2); transition: transform 0.1s;
            }
            input[type=range]::-webkit-slider-thumb:hover { transform: scale(1.1); }
            input[type=range]::-webkit-slider-runnable-track {
                width: 100%; height: 4px; cursor: pointer; 
                background: #cbd5e1; border-radius: 2px;
            }
            .group-toggle {
                display: inline-flex;
                align-items: center;
                padding: 0.5rem 0.75rem;
                margin: 0.25rem;
                border-radius: 0.5rem;
                font-size: 0.875rem;
                font-weight: 500;
                cursor: pointer;
                transition: all 0.2s;
                border: 2px solid transparent;
            }
            .group-toggle:hover {
                transform: translateY(-1px);
                box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            }
            .group-toggle.active {
                border-color: currentColor;
                box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
            }
            .group-toggle input[type="checkbox"] {
                margin-right: 0.5rem;
                width: 1rem;
                height: 1rem;
                cursor: pointer;
            }
        </style>
    </head>
    <body class="text-slate-800 p-4 md:p-8 min-h-screen flex flex-col items-center">

        <div class="w-full max-w-6xl mx-auto space-y-6">
            
            <!-- Title -->
            <div class="flex flex-col md:flex-row md:items-end justify-between gap-4">
                <div>
                    <h1 class="text-3xl font-bold tracking-tight text-slate-900">Cumulative perceived greenspace effect on LPA</h1>
                    <p class="text-slate-500 mt-2 text-sm max-w-2xl">
                        This panel shows the cumulative effect of perceived greenspace on LPA across different geographic contexts over time. 
                        Left panel shows overall trends with confidence intervals, right panel shows forest plot at the specific window.
                    </p>
                </div>
                <div class="text-right hidden md:block">
                    <span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-blue-100 text-blue-800">
                        Interactive Report
                    </span>
                </div>
            </div>

            <!-- Control Panel -->
            <div class="bg-white p-5 rounded-xl shadow-sm border border-slate-200 flex flex-col sm:flex-row items-center gap-6">
                <button id="playBtn" class="flex-none flex items-center justify-center w-12 h-12 rounded-full bg-blue-600 hover:bg-blue-700 text-white transition shadow-md focus:ring-2 focus:ring-offset-2 focus:ring-blue-500">
                    <svg id="icon-play" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="5 3 19 12 5 21 5 3"></polygon></svg>
                    <svg id="icon-pause" class="hidden" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="6" y="4" width="4" height="16"></rect><rect x="14" y="4" width="4" height="16"></rect></svg>
                </button>
                
                <div class="flex-1 w-full">
                    <div class="flex justify-between items-end mb-2">
                        <span class="text-xs font-medium text-slate-400 uppercase tracking-wider">Window Control</span>
                        <div class="text-2xl font-bold text-blue-600 font-mono" id="current-time-display">--</div>
                    </div>
                    <input type="range" id="timeSlider" min="0" max="100" value="0" step="1">
                    <div class="flex justify-between text-xs text-slate-400 mt-2">
                        <span id="start-time-label">Start</span>
                        <span id="end-time-label">End</span>
                    </div>
                </div>
            </div>

            <!-- Charts -->
            <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
                
                <!-- Trajectory Chart -->
                <div class="lg:col-span-2 chart-card p-1 relative">
                    <div class="absolute top-4 left-4 z-10 bg-white/90 px-2 py-1 rounded text-xs font-bold text-slate-500 shadow-sm border border-slate-100">
                        Overall Trend
                    </div>
                    <div id="loading" class="absolute inset-0 flex items-center justify-center bg-white z-20">
                        <span class="text-slate-400 animate-pulse">Loading Data...</span>
                    </div>
                    <div id="trajectoryChart" class="w-full h-[450px]"></div>
                </div>

                <!-- Forest Plot -->
                <div class="lg:col-span-1 chart-card p-1 relative">
                    <div class="absolute top-4 left-4 z-10 bg-white/90 px-2 py-1 rounded text-xs font-bold text-slate-500 shadow-sm border border-slate-100">
                        Current Snapshot
                    </div>
                    <div id="forestChart" class="w-full h-[450px]"></div>
                </div>
            </div>

            <!-- Group Selection Panel (moved below trajectory chart) -->
            <div class="bg-white p-5 rounded-xl shadow-sm border border-slate-200">
                <div class="flex justify-between items-center mb-3">

                    <div class="flex gap-2">
                        <button id="selectAllBtn" class="text-xs px-3 py-1 rounded bg-blue-50 text-blue-600 hover:bg-blue-100 transition">Select All</button>
                        <button id="deselectAllBtn" class="text-xs px-3 py-1 rounded bg-slate-50 text-slate-600 hover:bg-slate-100 transition">Deselect All</button>
                    </div>
                </div>
                <div id="groupToggles" class="flex flex-wrap gap-1"></div>
            </div>
            
        </div>

        <script>
            const rawJsonData = [
    {
        "time": 0,
        "group": "Overall",
        "val": 0.0337042692692642,
        "low": 0.0482204644495909,
        "high": 0.0181869571799495
    },
    {
        "time": 0,
        "group": "Work or Study",
        "val": 0.0395590690092141,
        "low": 0.0712590505232411,
        "high": 0.0080789726258475
    },
    {
        "time": 0,
        "group": "Housework",
        "val": 0.0433008236984039,
        "low": 0.1019843214690665,
        "high": -0.0153366301202081
    },
    {
        "time": 0,
        "group": "Personal activities",
        "val": 0.0609104585884523,
        "low": 0.0919530519444359,
        "high": 0.0300370095295832
    },
    {
        "time": 0,
        "group": "Leisure",
        "val": 0.0494951533655265,
        "low": 0.0818255866684942,
        "high": 0.0164760548619506
    },
    {
        "time": 0,
        "group": "Mixed activities",
        "val": 0.0485054924334446,
        "low": 0.1043212444544499,
        "high": -0.0066281456106592
    },
    {
        "time": 0,
        "group": "Active travel",
        "val": 0.1574069329152493,
        "low": 0.2366681407477505,
        "high": 0.078899211987901
    },
    {
        "time": 0,
        "group": "Motor travel",
        "val": 0.0182747255952648,
        "low": 0.0776680593289027,
        "high": -0.0409857333732712
    },
    {
        "time": 0,
        "group": "Mixed travel",
        "val": -0.018403495788755,
        "low": 0.0092155664548258,
        "high": -0.0461770208868719
    }
];

            let uniqueTimes = [];
            let uniqueGroups = [];
            let groupedData = {};
            let isPlaying = false;
            let animationId = null;
            let selectedGroups = new Set();
            
            const slider = document.getElementById('timeSlider');
            const timeDisplay = document.getElementById('current-time-display');
            const playBtn = document.getElementById('playBtn');
            const iconPlay = document.getElementById('icon-play');
            const iconPause = document.getElementById('icon-pause');
            const selectAllBtn = document.getElementById('selectAllBtn');
            const deselectAllBtn = document.getElementById('deselectAllBtn');
            const groupTogglesContainer = document.getElementById('groupToggles');

            const colors = ["#00224d", "#1a386f", "#434e6b", "#61646f", "#7c7b78", "#9b9376", "#bbad6c", "#dec957", "#fde737"];
            const forestPlotOrder = ["Mixed travel", "Motor travel", "Active travel", "Mixed activities", "Leisure", "Personal activities", "Housework", "Work or Study", "Overall"];

            function init() {
                if (!rawJsonData || rawJsonData.length === 0) return;

                const timeSet = new Set(rawJsonData.map(d => d.time));
                uniqueTimes = Array.from(timeSet).sort((a, b) => a - b);
                
                const groupSet = new Set(rawJsonData.map(d => d.group));
                uniqueGroups = Array.from(groupSet);

                // Initialize all groups as selected
                uniqueGroups.forEach(g => selectedGroups.add(g));

                uniqueGroups.forEach(g => {
                    groupedData[g] = rawJsonData
                        .filter(d => d.group === g)
                        .sort((a, b) => a.time - b.time);
                });

                slider.max = uniqueTimes.length - 1;
                document.getElementById('start-time-label').innerText = uniqueTimes[0];
                document.getElementById('end-time-label').innerText = uniqueTimes[uniqueTimes.length - 1];

                createGroupToggles();
                drawTrajectoryChart();
                drawForestChart(0);

                document.getElementById('loading').style.display = 'none';

                slider.addEventListener('input', (e) => {
                    updateViews(parseInt(e.target.value));
                });

                playBtn.addEventListener('click', togglePlay);
                selectAllBtn.addEventListener('click', selectAllGroups);
                deselectAllBtn.addEventListener('click', deselectAllGroups);
            }

            function createGroupToggles() {
                groupTogglesContainer.innerHTML = '';
                uniqueGroups.forEach((g, i) => {
                    const color = colors[i % colors.length];
                    const label = document.createElement('label');
                    label.className = 'group-toggle active';
                    label.style.backgroundColor = color + '22';
                    label.style.color = color;
                    
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.checked = true;
                    checkbox.dataset.group = g;
                    checkbox.addEventListener('change', (e) => {
                        if (e.target.checked) {
                            selectedGroups.add(g);
                            label.classList.add('active');
                        } else {
                            selectedGroups.delete(g);
                            label.classList.remove('active');
                        }
                        drawTrajectoryChart();
                    });
                    
                    const text = document.createTextNode(g);
                    label.appendChild(checkbox);
                    label.appendChild(text);
                    groupTogglesContainer.appendChild(label);
                });
            }

            function selectAllGroups() {
                uniqueGroups.forEach(g => selectedGroups.add(g));
                document.querySelectorAll('#groupToggles input[type="checkbox"]').forEach(cb => {
                    cb.checked = true;
                    cb.parentElement.classList.add('active');
                });
                drawTrajectoryChart();
            }

            function deselectAllGroups() {
                selectedGroups.clear();
                document.querySelectorAll('#groupToggles input[type="checkbox"]').forEach(cb => {
                    cb.checked = false;
                    cb.parentElement.classList.remove('active');
                });
                drawTrajectoryChart();
            }

            function getMinVal() {
                const filteredData = rawJsonData.filter(d => selectedGroups.has(d.group));
                if (filteredData.length === 0) return 0;
                return Math.min(...filteredData.map(d => d.low));
            }

            function getMaxVal() {
                const filteredData = rawJsonData.filter(d => selectedGroups.has(d.group));
                if (filteredData.length === 0) return 0;
                return Math.max(...filteredData.map(d => d.high));
            }

            function drawTrajectoryChart() {
                const traces = [];
                uniqueGroups.forEach((g, i) => {
                    if (!selectedGroups.has(g)) return;
                    
                    const groupData = groupedData[g];
                    const color = colors[i % colors.length];
                    
                    // Add confidence interval
                    traces.push({
                        x: [...groupData.map(d => d.time), ...groupData.map(d => d.time).reverse()],
                        y: [...groupData.map(d => d.high), ...groupData.map(d => d.low).reverse()],
                        fill: 'toself',
                        fillcolor: color + '33',
                        line: { color: 'transparent' },
                        showlegend: false,
                        hoverinfo: 'skip',
                        name: g + ' CI'
                    });
                    
                    // Add main line
                    traces.push({
                        x: groupData.map(d => d.time),
                        y: groupData.map(d => d.val),
                        mode: 'lines',
                        name: g,
                        line: { color: color, width: 3, shape: 'spline' },
                        hovertemplate: `<b>${g}</b><br>Mean: %{y:.3f}, CI: [%{customdata[0]:.3f}, %{customdata[1]:.3f}]<extra></extra>`,
                        customdata: groupData.map(d => [d.low, d.high])
                    });
                });

                const indicatorLine = {
                    x: [uniqueTimes[0], uniqueTimes[0]],
                    y: [getMinVal(), getMaxVal()],
                    mode: 'lines',
                    name: 'Current Time',
                    line: { color: '#64748b', width: 2, dash: 'dash' },
                    hoverinfo: 'none',
                    showlegend: false
                };

                const layout = {
                    margin: { t: 40, r: 20, l: 50, b: 40 },
                    showlegend: true,
                    legend: { orientation: 'h', y: -0.15, x: 0.5, xanchor: 'center' },
                    xaxis: { title: 'Window', gridcolor: '#f1f5f9' },
                    yaxis: { title: 'Average treatment effect (ATE)', gridcolor: '#f1f5f9' },
                    plot_bgcolor: '#ffffff',
                    paper_bgcolor: '#ffffff',
                    hovermode: 'x unified',
                    shapes: [
                        {
                            type: 'line',
                            x0: uniqueTimes[0],
                            x1: uniqueTimes[uniqueTimes.length - 1],
                            y0: 0,
                            y1: 0,
                            line: {
                                color: '#ef4444',
                                width: 3,
                                dash: 'dash'
                            }
                        }
                    ]
                };

                Plotly.newPlot('trajectoryChart', [...traces, indicatorLine], layout, {displayModeBar: false, responsive: true});
            }

            function drawForestChart(timeIndex) {
                const currentTime = uniqueTimes[timeIndex];
                timeDisplay.innerText = currentTime;

                // Always show all groups in forest plot, regardless of selectedGroups
                const currentData = rawJsonData.filter(d => d.time === currentTime);
                
                // Sort data according to forestPlotOrder (top to bottom)
                const sortedData = currentData.sort((a, b) => {
                    const indexA = forestPlotOrder.indexOf(a.group);
                    const indexB = forestPlotOrder.indexOf(b.group);
                    return indexA - indexB;
                });

                const trace = {
                    type: 'scatter',
                    mode: 'markers',
                    x: sortedData.map(d => d.val),
                    y: sortedData.map(d => d.group),
                    error_x: {
                        type: 'data',
                        symmetric: false,
                        array: sortedData.map(d => d.high - d.val),
                        arrayminus: sortedData.map(d => d.val - d.low),
                        visible: true,
                        color: '#475569',
                        width: 3,
                        thickness: 2
                    },
                    marker: {
                        size: 16,
                        color: sortedData.map(d => {
                            const idx = uniqueGroups.indexOf(d.group);
                            return colors[idx % colors.length];
                        }),
                        line: { color: 'white', width: 2 }
                    },
                    hovertemplate: `<b>%{y}</b><br>Value: %{x:.3f}<extra></extra>`
                };

                const layout = {
                    margin: { t: 40, r: 20, l: 120, b: 40 },
                    xaxis: { title: 'Average treatment effect (ATE)', gridcolor: '#f1f5f9', zeroline: false },
                    yaxis: { 
                        title: '', 
                        gridcolor: '#f1f5f9', 
                        type: 'category',
                        categoryorder: 'array',
                        categoryarray: forestPlotOrder
                    },
                    plot_bgcolor: '#ffffff',
                    paper_bgcolor: '#ffffff',
                    showlegend: false,
                    shapes: [
                        {
                            type: 'line',
                            x0: 0,
                            x1: 0,
                            y0: -0.5,
                            y1: sortedData.length - 0.5,
                            line: {
                                color: '#ef4444',
                                width: 3,
                                dash: 'dash'
                            }
                        }
                    ]
                };

                const chartDiv = document.getElementById('forestChart');
                if (chartDiv.data) {
                    Plotly.react('forestChart', [trace], layout, {displayModeBar: false, responsive: true});
                } else {
                    Plotly.newPlot('forestChart', [trace], layout, {displayModeBar: false, responsive: true});
                }
            }

            function updateViews(timeIndex) {
                const currentTime = uniqueTimes[timeIndex];
                
                drawForestChart(timeIndex);

                const update = {
                    x: [[currentTime, currentTime]]
                };
                const traceIndex = document.getElementById('trajectoryChart').data.length - 1;
                Plotly.restyle('trajectoryChart', update, [traceIndex]);
            }

            function togglePlay() {
                isPlaying = !isPlaying;
                if (isPlaying) {
                    iconPlay.classList.add('hidden');
                    iconPause.classList.remove('hidden');
                    animate();
                } else {
                    iconPlay.classList.remove('hidden');
                    iconPause.classList.add('hidden');
                    if (animationId) cancelAnimationFrame(animationId);
                }
            }

            function animate() {
                let currentIndex = parseInt(slider.value);
                if (currentIndex >= uniqueTimes.length - 1) {
                    currentIndex = 0;
                } else {
                    currentIndex++;
                }
                slider.value = currentIndex;
                updateViews(currentIndex);

                if (isPlaying) {
                    animationId = setTimeout(() => requestAnimationFrame(animate), 500);
                }
            }

            window.addEventListener('load', init);
        </script>
    </body>
    </html>
    